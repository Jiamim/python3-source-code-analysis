{"./":{"url":"./","title":"前言","keywords":"","body":"介绍 本项目致力于对 Python 3.7 的源码分析，深度参考陈儒大大的《Python 源码剖析》，编写 Python 3 的版本。 希望各位 Python 爱好者能参与其中，一起探索 Python 魔法背后的奥秘！ 使用 您可以直接访问 在线版，或者根据以下步骤访问本地版。 前置条件 您的系统上需要安装好 node。 使用 make 命令 若您可使用 make 命令，简单执行如下命令进行初始化： make init 执行如下命令运行服务端： make run 使用 gitbook 命令 若您不能使用 make 命令，或想直接使用 gitbook 命令，执行如下命令进行初始化： npm i -g gitbook-cli #可能需要sudo gitbook install 执行如下命令运行服务端： gitbook serve 访问 直接访问 http://localhost:4000 即可查看本书内容。 Roadmap 大体按照《Python 源码剖析》中的目录结构进行编写。依次介绍 Python 源码基本信息、内建对象和虚拟机。 [x] 章节 [x] 序章 [x] 前言 [x] Python 源代码的组织 [x] Windows 环境下编译 Python [x] UNIX/Linux 环境下编译 Python [x] 修改 Python 源码 [ ] Python 内建对象 [x] Python 对象初探 [ ] Python 整数对象 [ ] Python 字符串 对象 [ ] Python List 对象 [ ] Python Dict 对象 [ ] Python Set 对象 [ ] 实现简版 Python [ ] Python 虚拟机 [ ] Python 编译结果 [ ] Python 虚拟机框架 [ ] 虚拟机一般表达式 [ ] Python 虚拟机控制流 [ ] Python 虚拟机函数机制 [ ] Python 运行环境初始化 [ ] Python 模块加载机制 [ ] Python 多线程机制 [ ] Python 内存管理机制 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"preface/code-organization.html":{"url":"preface/code-organization.html","title":"Python 源代码的组织","keywords":"","body":"Python 源代码的组织 源代码下载 方式 1：GitHub Python 源代码可以在 GitHub 上方便的获取，执行： git clone https://github.com/python/cpython.git git checkout v3.7.0 即可获取 Python 3.7.0 版本的代码。 方式 2：Python 官方网站 访问 https://www.python.org/downloads/release/python-370/ ，下拉至页面最下方，可选择下载 tarball 源码包。 亦可执行： wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz 即可获取 Python 3.7.0 版本的代码。 目录结构 进入源码目录，我们可以看到该目录下主要 包含以下文件（夹）： . ├── Doc ├── Grammar ├── Include ├── LICENSE ├── Lib ├── Mac ├── Makefile.pre.in ├── Misc ├── Modules ├── Objects ├── PC ├── PCbuild ├── Parser ├── Programs ├── Python ├── README.rst ├── Tools ├── aclocal.m4 ├── config.guess ├── config.sub ├── configure ├── configure.ac ├── install-sh ├── m4 ├── pyconfig.h.in └── setup.py 其中： Include 目录：包含了 Python 提供的所有头文件，如果用户需要自己用 C 或 C++来编写自定义模块扩展 Python，那么就需要用到这里提供的头文件。 Lib 目录：包含了 Python 自带的所有标准库，且都是用 Python 语言编写的。 Modules 目录：包含了所有用 C 语言编写的模块，比如 math、hashlib 等。它们都是那些对速度要求非常严格的模块。而相比而言，Lib 目录下则是存放一些对速度没有太严格要求的模块，比如 os。 Parser 目录：包含了 Python 解释器中的 Scanner 和 Parser 部分，即对 Python 源代码进行词法分析和语法分析的部分。除此以外，此目录还包含了一些有用的工具，这些工具能够根据 Python 语言的语法自动生成 Python 语言的词法和语法分析器，与 YACC 非常类似。 Objects 目录：包含了所有 Python 的内建对象，包括整数、list、dict 等。同时，该目录还包括了 Python 在运行时需要的所有的内部使用对象的实现。 Python 目录：包含了 Python 解释器中的 Compiler 和执行引擎部分，是 Python 运行的核心所在。 PCbuild 目录：包含了 Visual Studio 2003 的工程文件，研究 Python 源代码就从这里开始（本书将采用 Visual Studio 2017 对 Python 进行编译）。 Programs 目录：包含了 Python 二进制可执行文件的源码。 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"preface/windows-build.html":{"url":"preface/windows-build.html","title":"Windows 环境下编译 Python","keywords":"","body":"Windows 环境下编译 Python 在 Windows 环境下编译 Python 可完全通过界面操作，主要分为两个步骤： 环境准备 编译 环境准备 在 Python 3.6 及之后的版本可以使用微软的 Visual Studio 2017 进行编译，选择社区版就足够了。 在下载完成后，需要注意安装环节的选项。由于 Python 3.7 所使用的 Windows SDK 的版本为 10.0.17134.0， 所以需要选择安装该 SDK，如下图所示： 编译 进入 Python 源码根目录，打开 PCbuild\\pcbiuld.sln 解决方案，而后进行一些设置： 在左侧的解决方案目录的顶端，右键选择“属性”，以打开属性界面（如下图所示）。 由于我们只是研究 Python 的核心部分，可以选择不编译标准库和外部依赖，在“配置属性”->“配置”中仅勾选 python 和 pythoncore，然后点击“确定”（如下图所示）。 此外，默认情况下的编译设置是 Debug、32 位，您也可以根据自己的需求调整成 Release 或 64 位。 在左侧的解决方案目录中选择 python，右键选择“生成”，以进行编译： 编译结束后，生成的文件存放在PCbuild\\win32目录下（如下图所示），打开python_d即可打开新生成的 Python 3.7 解释器。 更多内容 更多关于在 Windows 上进行编译和开发 Python 的内容见官方指南 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"preface/unix-linux-build.html":{"url":"preface/unix-linux-build.html","title":"UNIX/Linux 环境下编译 Python","keywords":"","body":"UNIX/Linux 环境下编译 Python 在 UNIX/Linux 环境下编译 Python 较为简单，主要分为两个步骤： 环境准备（准备 Python 所依赖的必要环境） 编译、安装 环境准备 常规操作系统中 编译 Python 前通常需要在系统上安装以下库： gcc // 编译工具 zlib // 压缩、解压相关库 libffi // Python 所以来的用于支持 C 扩展的库 openssl // 安全套接字层密码库，Linux 中通常已具备 不同的发行版，安装方式和包名称也不尽相同。 对于 Debian/Ubuntu，执行： sudo apt install -y zlib1g zlib1g-dev libffi-dev openssl libssl-dev 对于 RedHat/CentOS/Fedora，执行： yum install -y zlib zlib-devel libffi-devel openssl openssl-devel 对于 macOS，执行： xcode-select --install 运行于 Docker 的操作系统中 Docker 版的 Linux 发行版可能会有较多的库未安装，除了安装上一小节提及的库外，其他缺失库可根据情况自行安装： bzip2 // 压缩库 readline // GNU Readline 是一个软件库，它为使用命令行界面（如 Bash）的交互式程序提供了行编辑和历史功能 sqlite // 由 C 编写的小型数据库 libuuid // 跨平台的开源的 uuid 操作库 gdbm // 小型的数据库系统 xz // 压缩解压工具 tk-devel // 图形用户界面开发工具 对于 Debian/Ubuntu，执行： sudo apt-get install bzip2 libbz2-dev sqlite3 libsqlite3-dev libreadline6 libreadline6-dev libgdbm-dev uuid-dev tk-dev 对于 RedHat/CentOS/Fedora，执行： yum install bzip2 bzip2-devel readline-devel sqlite-devel libuuid-devel gdbm-devel xz-devel tk-devel 编译、安装 进入 Python 源码根目录，执行以下命令： ./configure make make install Python 将会被编译，并安装在默认目录中。若您希望将 Python 安装在特定目录，则需要在一开始修改 configure 命令为： ./configure –-prefix= 在指定目录中: bin 目录 存放的是可执行文件 include 目录 存放的是 Python 源码的头文件 lib 目录 存放的是 Python 标准库 lib/python3.7/config-3.7m-{platform} 目录 存放的是 libpython3.7m.a，该静态库用于使用 C 语言进行扩展。{platform} 代表平台，比如在 Mac OS 上为 “darwin”，在 Linux 上为 “x86_64-linux-gnu” share 目录 存放的是帮助等文件 默认情况下，编译的 Python 是静态链接（libpython3.7m.a）。如果希望编译的 Python 是动态链接（libpython3.7m.so），则需要在一开始修改configure 命令为： ./configure --enable-shared 如需重新编译，请首先执行： make clean 再执行本节开头处的命令即可。 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"preface/modify-code.html":{"url":"preface/modify-code.html","title":"修改 Python 源码","keywords":"","body":"修改 Python 源码 在源代码中 Print 在接下来研究源码的过程中，我们可能会对某些语句的逻辑感到好奇，需要输出中间结果。 这就需要借助 Python C API 中打印对象的接口： 源文件：Objects/object.c int PyObject_Print(PyObject *op, FILE *fp, int flags) 比如，我们希望在解释器交互界面中打印整数值的时候输出一段字符串，则我们可以修改如下函数： 源文件：Objects/longobject.c static PyObject * long_to_decimal_string(PyObject *aa) { PyObject *str = PyUnicode_FromString(\"I am always before int\"); PyObject_Print(str, stdout, 0); printf(\"\\n\"); PyObject *v; if (long_to_decimal_string_internal(aa, &v, NULL, NULL, NULL) == -1) return NULL; return v; } 函数实现中的前 3 行为我们加入的代码，其中： PyUnicode_FromString 用于把 C 中的原生字符数组转换为出 Python 中的字符串（Unicode）对象 PyObject_Print 则将转换好的字符串对象打印至我们指定的标准输出（stdout） 对 Python 重新进行编译，在 Unix 上可执行： make && make bininstall 运行编译后的 Python，输入 print 语句即可看到我们希望的结果： >>> print(1) 'I am always before int' 1 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"objects/object.html":{"url":"objects/object.html","title":"Python 对象初探","keywords":"","body":"Python 对象初探 在Python的世界中，一切皆对象。不论是是整数，还是字符串，甚至连类型、函数等都是一种对象。 Python中有一些已经定义好的类型对象，如int类型、str类型和dict类型等， 我们把这些对象称为内建类型对象，这些类型对象通过“实例化”可以创建内建类型对象的实例对象， 如int对象、str对象和dict对象等。 Python还允许我们通过class A(object)这样的形式自定义类型对象，我们同样可以对自定义的 类型对象“实例化”从而生成“实例对象”。这些对象之间存在的各种复杂关系构成了“类型系统”和“对象系统”。 Python的类型系统和对象系统非常庞大复杂，我们将分成多篇来解读。本章我们着重于了解对象在Python内部是如何表示的。 Python 内的对象 对于计算机而言，对象是一个抽象的概念，计算机不懂对象是什么也不能理解字符串、整数是什么， 它所知道的一切都是字节。在计算机中，一个对象的实际的表示就是一片被分配的内存空间，这些内存可能是连续的也可能是离散的，而这片内存所代表的一个整体就是一个对象，它可以存储一系列数据，我们可以对这些数据进行读写等一系列行为。 在Python中，对象就是以C语言中的结构体在堆上申请一块内存为代表的。一个对象一旦创建它的内存大小就不再改变，那些需要容纳变长数据的对象需要在内维护一个指向一块可变大小的内存区域的指针，这样做的好处是可以通过指针非常方便的管理维护对象。 对象机制的基石 PyObject 在Python中，所有对象都拥有一些相同的内容，这些内容定义在PyObject中， 可以说 PyObject 是一切对象的基础， 它包含 一个用于垃圾回收的双向链表，一个引用计数变量 ob_refcnt 和 一个类型对象指针ob_type 源文件：Include/object.h // Include/object.h #define _PyObject_HEAD_EXTRA \\ struct _object *_ob_next; \\ struct _object *_ob_prev; typedef struct _object { _PyObject_HEAD_EXTRA // 双向链表 垃圾回收 需要用到 Py_ssize_t ob_refcnt; // 引用计数 struct _typeobject *ob_type; // 指向类型对象的指针，决定了对象的类型 } PyObject; 在Python的定义中，对于一个整型对象longobj，它的变量ob_refcnt与内存管理机制有关，它实现了基于 引用计数的垃圾回收机制。当一个新的对象引用该对象longobj时，longobj的引用计数增加，而当该引用被删除时候，longobj的引用计数减少。 当longobj的变量ob_refcnt减少为0时，该对象longobj从堆上被删除，释放出内存供其他对象使用。 ob_type是一个指向_typeobject的结构体指针，它对应着Python内部的一类 特殊对象(类型对象)，类型对象用于表示一个对象的类型。 在PyObject中定义的内容每一个Python对象都必须有，这些内容在每一个Python 对象占用的内存空间的最开始的字节中。 定长对象和变长对象 源文件：Include/object.h // Include/object.h typedef struct _object { _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; struct _typeobject *ob_type; } PyObject; typedef struct { PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part */ } PyVarObject; 变长对象PyVarObject与PyObject的不同在于多了一个ob_size变量，ob_size用于保存元素的个数 Python中的整数对象，除了PyObject_VAR_HEAD外还有一个额外的东西ob_digit, 这个整数对象的值就保存在ob_digit中。Python中的字符串对象、list对象、 dict对象等除了PyObject以外都有一些属于自己的特殊信息。 源文件：Include/object.h // Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base; 源文件：Objects/longobject.h // Include/longobject.h typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */ 源文件：Include/longintrepr.h // Include/longintrepr.h struct _longobject { PyObject_VAR_HEAD digit ob_digit[1]; }; 类型对象 Python中的对象开始的一些字节中的内容我们是可以明确知道的，双向链表 ob_refcnt和ob_type; 在创建对象需要知道分配多少内存空间，这个时候 我们需要从对象的元信息去找该对象到底该分配多少内存，而这个元信息就在 该对象的类型对象中，也就是ob_type所指向的对象中。 接下来我们就看看这个类型对象到底长什么样 在 _typeobject 的定义中包含许多信息，主要分类以下几类: 类型名, tp_name, 主要用于 Python 内部调试用 创建该类型对象时分配的空间大小信息，即 tp_basicsize 和 tp_itemsize 与该类型对象相关的操作信息(如 tp_print 这样的函数指针) 一些对象属性 源文件：Include/object.h // Include/object.h typedef struct _typeobject { PyObject_VAR_HEAD const char *tp_name; /* For printing, in format \".\" */ // 类型名 Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ // 创建该类型对象分配的内存空间大小 // 一堆方法定义，函数和指针 /* Methods to implement standard operations */ destructor tp_dealloc; printfunc tp_print; getattrfunc tp_getattr; setattrfunc tp_setattr; PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2) or tp_reserved (Python 3) */ reprfunc tp_repr; /* Method suites for standard classes */ // 标准类方法集 PyNumberMethods *tp_as_number; // 数值对象操作 PySequenceMethods *tp_as_sequence; // 序列对象操作 PyMappingMethods *tp_as_mapping; // 字典对象操作 // 更多标准操作 /* More standard operations (here for binary compatibility) */ hashfunc tp_hash; ternaryfunc tp_call; reprfunc tp_str; getattrofunc tp_getattro; setattrofunc tp_setattro; ...... } PyTypeObject; 对象的创建 一般来说，Python会有两种方式创建对象 通过 Python C API 来创建 通过类型对象创建 范型API 或称为 AOL (Abstract Object Layer) 这类API通常形如PyObject_XXX这样的形式。可以应用在任何Python对象上，如PyObject_Print 与类型相关的API 或称为 COL (Concrete Object Layer) 这类API 通常只能作用于某一种类型的对象上，对于每一种内建对象 Python都提供了这样一组API。例如整数对象，我们可以利用如下的API创建 PyObject *longObj = PyLong_FromLong(10); 对象的行为 在 PyTypeObject 中定义了大量的函数指针。这些函数指针可以视为类型对象中 所定义的操作，这些操作直接决定着一个对象在运行时所表现出的行为。 比如 PyTypeObject 中的 tp_hash 指明了该类型对象如何生成其hash值。 在之前的PyTypeObject代码中，我们可以看到非常重要的三组操作族 PyNumberMethods *tp_as_number、PySequenceMethods *tp_as_sequence、PyMappingMethods *tp_as_mapping， 源文件：Include/object.h // Include/object.h typedef PyObject * (*binaryfunc)(PyObject *, PyObject *); typedef struct { binaryfunc nb_matrix_multiply; binaryfunc nb_inplace_matrix_multiply; ...... } PyNumberMethods; 在PyNumberMethods定义了一个数值对象该支持的操作。一个数值对象如 整数对象，那么它的类型对象 PyLong_Type中,tp_as_number.nb_add 就指定了它进行加法操作时的具体行为。PyMappingMethods与PySequenceMethods与此相同。 在以下代码中可以看出PyLong_Type中的tp_as_number项指向的是long_as_number 源文件：Objects/longobject.h // Objects/longobject.c static PyNumberMethods long_as_number = { (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ ...... }; PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ long_dealloc, /* tp_dealloc */ 0, /* tp_print */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_reserved */ long_to_decimal_string, /* tp_repr */ &long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ ...... }; 类型的类型 在 PyTypeObjet 定义开始有 PyOject_VAR_HEAD，这意味着 Python 中的类型实际上也是一个对象。在Python中一切东西都是对象，那么类型对象的类型是什么呢？ 对于其他对象，可以通过与其关联的对象确定其类型，那么通过什么来确定一个对象是类型对象呢？ 答案就是 PyType_Type 源文件：Objects/typeobject.c // Objects/typeobject.c PyTypeObject PyType_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"type\", /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ ...... }; PyType_Type 在Python的类型机制中至关重要，所有用户自定义 class 所 对应的 PyTypeObject 对象都是通过 PyType_Type创建的 接下来我们看 PyLong_Type 是怎么与 PyType_Type 建立联系的。 前面提到，在Python中，每一个对象都将自己的引用计数、类型信息保存在开始的部分中。 为了方便对这部分内存初始化，Python中提供了几个有用的宏: 源文件：Include/object.h // Include/object.h #ifdef Py_TRACE_REFS #define _PyObject_EXTRA_INIT 0, 0, #else #define _PyObject_EXTRA_INIT #endif #define PyObject_HEAD_INIT(type) \\ { _PyObject_EXTRA_INIT \\ 1, type }, 再回顾下 PyObject和PyVarObject的定义，初始化动作就一目了然了。 实际上，这些宏在各种内建类型对象的初始化中被大量使用。 以PyLong_Type为例，可以更清晰的看到一般的类型对象和PyType_type之间的关系 源文件：Objects/longobject.c // Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ ...... }; 下图是对象运行时的图像表现 Python 对象的多态性 Python创建一个对象比如 PyLongObject 时，会分配内存进行初始化，然后 Python内部会用 PyObject* 变量来维护这个对象，其他对象也与此类似， 所以在 Python 内部各个函数之间传递的都是一种范型指针 PyObject* 我们不知道这个指针所指的对象是什么类型，只能通过所指对象的 ob_type 域 动态进行判断，而Python正是通过 ob_type 实现了多态机制 考虑以下的 Print 函数 void Print(PyObject* object) { object->ob_type->tp_print(object); } 如果传递给 Print 函数的指针是一个 PyLongObject*，那么它会调用 PyLongOjbect 对象对应的类型对象中定义的 输出操作 如果指针是一个 PyUnicodeObject*，那么就会调用 PyUnicodeObject 对象对应的类型对象中定义的输出操作 引用计数 Python 通过引用计数来管理维护对象在内存中的存在与否 Python 中的每个东西都有一个对象， 都有ob_refcnt 变量 这个变量维护对象的引用计数，从而最终决定该对象的创建与销毁 在Python中，主要通过 Py_INCREF(op)与Py_DECREF(op) 这两个宏 来增加和减少对一个对象的引用计数。当一个对象的引用计数减少到0之后， Py_DECREF将调用该对象的tp_dealloc来释放对象所占用的内存和系统资源 源文件：Include/object.h // Include/object.h #define _Py_NewReference(op) ( \\ _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA \\ _Py_INC_REFTOTAL _Py_REF_DEBUG_COMMA \\ Py_REFCNT(op) = 1) #define Py_INCREF(op) ( \\ _Py_INC_REFTOTAL _Py_REF_DEBUG_COMMA \\ ((PyObject *)(op))->ob_refcnt++) #define Py_DECREF(op) \\ do { \\ PyObject *_py_decref_tmp = (PyObject *)(op); \\ if (_Py_DEC_REFTOTAL _Py_REF_DEBUG_COMMA \\ --(_py_decref_tmp)->ob_refcnt != 0) \\ _Py_CHECK_REFCNT(_py_decref_tmp) \\ else \\ _Py_Dealloc(_py_decref_tmp); \\ } while (0) 一个对象引用计数减为0时，该对象的析构函数被调用，但调用析构函数并不意味着最终一定会调用 free 释放内存空间。 因为频繁的申请、释放内存会大大降低Python的执行效率。 因此Python中大量采用了内存对象池的技术，使得对象释放的空间归还给内存池而不是直接free，后续使用可先从对象池中获取 Python 对象的分类 Fundamental 对象: 类型对象 Numeric 对象: 数值对象 Sequence 对象: 容纳其他对象的序列集合对象 Mapping 对象: 类似 C++中的 map 的关联对象 Internal 对象: Python 虚拟机在运行时内部使用的对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"objects/long-object.html":{"url":"objects/long-object.html","title":"Python 整数对象","keywords":"","body":"Python 整数对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"objects/string-object.html":{"url":"objects/string-object.html","title":"Python 字符串 对象","keywords":"","body":"Python 字符串 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"objects/list-object.html":{"url":"objects/list-object.html","title":"Python List 对象","keywords":"","body":"Python List 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"objects/dict-object.html":{"url":"objects/dict-object.html","title":"Python Dict 对象","keywords":"","body":"Python Dict 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"objects/set-object.html":{"url":"objects/set-object.html","title":"Python Set 对象","keywords":"","body":"Python Set 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "},"objects/simple-implementation.html":{"url":"objects/simple-implementation.html","title":"实现简版 Python","keywords":"","body":"实现简版 Python Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-21 14:07:47 "}}